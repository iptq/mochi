use symbol::Symbol;

use crate::ast::{Class, Decl, DeclKind, Expr, ExprKind, Func, Stmt, StmtKind, Use};
use crate::scanner::Token;

#[LALR]
grammar;

pub Program: Vec<Decl> = (<Decl> Sep*)+;

/////

Class: Class = "class" Ident => Class { };

Decl: Decl = {
    <lo:@L> <class:Class> <hi:@R> => Decl { kind: DeclKind::Class(class), pos: (lo, hi) },
    <lo:@L> <func:Func> <hi:@R> => Decl { kind: DeclKind::Func(func), pos: (lo, hi) },
    <lo:@L> <_use:Use> <hi:@R> => Decl { kind: DeclKind::Use(_use), pos: (lo, hi) },
};

Expr: Expr = {
    <lo:@L> <expr1:Expr> <expr2:Expr2> <hi:@R> => Expr { kind: ExprKind::Call(Box::new(expr1), Box::new(expr2)), pos: (lo, hi) },
    <expr:Expr2> => expr,
};

Expr2: Expr = {
    <lo:@L> <expr:Expr3> "%" Int <hi:@R> => expr,
    <lo:@L> Match <hi:@R> => Expr { kind: ExprKind::Match, pos: (lo, hi) },
    <lo:@L> <expr1:Expr3> ".." <expr2:Expr3> <hi:@R> => Expr { kind: ExprKind::Range(Box::new(expr1), Box::new(expr2)), pos: (lo, hi) },
    <expr:Expr3> => expr,
};

Expr3: Expr = {
    <lo:@L> <path:Path> <hi:@R> => Expr { kind: ExprKind::Unit, pos: (lo, hi) },
    <lo:@L> <int:Int> <hi:@R> => Expr { kind: ExprKind::IntLiteral(int), pos: (lo, hi) },
    <lo:@L> <str:String> <hi:@R> => Expr { kind: ExprKind::StringLiteral(str), pos: (lo, hi) },
    <lo:@L> "(" ")" <hi:@R> => Expr { kind: ExprKind::Unit, pos: (lo, hi) },
    <lo:@L> "(" <expr:Expr> ")" <hi:@R> => Expr { kind: expr.kind, pos: (lo, hi) },
    <lo:@L> "(" <exprs:PunctTwo<",", Expr>> ")" <hi:@R> => Expr { kind: ExprKind::Tuple(exprs), pos: (lo, hi) },
};

Func: Func = "func" <name:Ident> <args:FuncArg*> FuncReturn? "=" <body:Body<MultiPunct<Sep, Stmt>>> => Func { };

FuncArg: () = {
    "(" <name:Ident> ":" <ty:Ident> ")" => {},
    <name:Ident> => {},
};

FuncReturn: () = "->" Ident => {};

Match: () = "match" Expr ":" Body<MultiPunct<Sep, MatchArm>> => ();

MatchArm: () = Pattern "=>" Expr => ();

Path: () = {
    Ident => (),
    Path "." Ident => (),
};

Pattern: () = {
    "_" => (),
    Int => (),
    "(" Punct<",", Pattern> ")" => (),
};

Stmt: Stmt = {
    <lo:@L> <expr:Expr> <hi:@R> => Stmt { kind: StmtKind::Expr(expr), pos: (lo, hi) },
    <lo:@L> "let" Ident "=" <expr:Expr> <hi:@R> => Stmt { kind: StmtKind::Let, pos: (lo, hi) },
    <lo:@L> "for" Ident "in" Expr ":" Body<MultiPunct<Sep, Stmt>> <hi:@R> => Stmt { kind: StmtKind::ForLoop, pos: (lo, hi) },
};

Use: Use = "use" UsePath => Use { };

UsePath: Vec<Symbol> = {
    <path:UsePath1> => path,
    <outer:UsePath1> "." "(" <inner:Punct<",", UsePath>> ")" => { let mut outer = outer.clone(); outer.extend(inner.into_iter().flatten()); outer },
};

UsePath1: Vec<Symbol> = {
    <name:Ident> => vec![name],
    <path:UsePath1> "." <name:Ident> => { let mut path = path.clone(); path.insert(0, name); path },
};

// macros

Body<T>: T = {
    Sep* Indent <t:T> Dedent => t,
};

MultiPunct<D, T>: Vec<T> = {
    <f:T?> <v:(D+ <T>)*> D* => match f {
        None => v,
        Some(f) => {
            let mut v = v;
            v.insert(0, f);
            v
        },
    }
}

Punct<D, T>: Vec<T> = {
    <f:T?> <v:(D <T>)*> D? => match f {
        None => v,
        Some(f) => {
            let mut v = v;
            v.insert(0, f);
            v
        },
    }
}

PunctOne<D, T>: Vec<T> = {
    <f:T> <v:(D <T>)*> D? => {
        let mut v = v;
        v.insert(0, f);
        v
    }
}

PunctTwo<D, T>: Vec<T> = {
    <f:T> D <s:T> <v:(D <T>)*> D? => {
        let mut v = v;
        v.insert(0, f);
        v.insert(1, s);
        v
    }
}

extern {
    type Location = usize;
    type Error = crate::scanner::ScanError;

    enum crate::scanner::Token {
        "class" => Token::KwdClass,
        "for" => Token::KwdFor,
        "func" => Token::KwdFunc,
        "in" => Token::KwdIn,
        "let" => Token::KwdLet,
        "match" => Token::KwdMatch,
        "use" => Token::KwdUse,

        "->" => Token::SymArrow,
        "=>" => Token::SymDblArrow,
        ".." => Token::SymDblDot,

        ":" => Token::SymColon,
        "," => Token::SymComma,
        "." => Token::SymDot,
        "=" => Token::SymEqual,
        "(" => Token::SymParenL,
        ")" => Token::SymParenR,
        "%" => Token::SymPercent,
        "_" => Token::SymUnderscore,

        Int => Token::IntLiteral(<String>),
        String => Token::StringLiteral(<String>),
        Ident => Token::Ident(<Symbol>),

        Indent => Token::Indent,
        Dedent => Token::Dedent,
        Sep => Token::Sep,
    }
}
