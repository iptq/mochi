use symbol::Symbol;

use crate::ast::*;
use crate::scanner::Token;

#[LALR]
grammar;

pub Program: Program = MultiPunct<Sep, Decl> => Program(<>);

pub Decl: Decl = {
    <func:Func> => Decl::Func(func),
};

pub Func: Func = {
    "fn" <name:Ident> <args:FuncArg*> <returns:FuncReturn?> ":" <body:Body<MultiPunctOne<Sep, Stmt>>> => Func { name, args, body, returns: returns.unwrap_or_else(|| Type::gen()) },
};

FuncArg: (Symbol, Type) = {
    "(" <name:Ident> ":" <ty:TypeLiteral> ")" => (name, ty),
    <name:Ident> => (name, Type::gen()),
};

FuncReturn: Type = "->" <ty:TypeLiteral> => ty;

Stmt: Stmt = {
    <expr:Expr> => Stmt::Expr(expr),
    "return" <expr:Expr> => Stmt::Return(expr),
};

Expr: Expr = {
    Int => Expr::Int(<>.parse::<i64>().unwrap()),
};

TypeLiteral: Type = {
    <ty:TypeLiteral2> => ty,
    <ty1:TypeLiteral2> "->" <ty2:TypeLiteral> => Type::Func(Vec::new(), Box::new(ty2)),
};

TypeLiteral2: Type = {
    <name:Ident> => Type::Name(name),
    "(" <ty:TypeLiteral> ")" => ty,
};

// util =======================================================================

Sep = {
    ";",
    LineSep,
};

Body<T>: T = {
    "(" <t:T> ")" => t,
    Sep* Indent <t:T> Dedent => t,
};

MultiPunct<D, T>: Vec<T> = {
    <f:T?> <v:(D+ <T>)*> D* => match f {
        None => v,
        Some(f) => {
            let mut v = v;
            v.insert(0, f);
            v
        },
    }
}

MultiPunctOne<D, T>: Vec<T> = {
    <f:T> <v:(D+ <T>)*> D* => {
        let mut v = v;
        v.insert(0, f);
        v
    }
}

Punct<D, T>: Vec<T> = {
    <f:T?> <v:(D <T>)*> D? => match f {
        None => v,
        Some(f) => {
            let mut v = v;
            v.insert(0, f);
            v
        },
    }
}

PunctOne<D, T>: Vec<T> = {
    <f:T> <v:(D <T>)*> D? => {
        let mut v = v;
        v.insert(0, f);
        v
    }
}

PunctTwo<D, T>: Vec<T> = {
    <f:T> D <s:T> <v:(D <T>)*> D? => {
        let mut v = v;
        v.insert(0, f);
        v.insert(1, s);
        v
    }
}

extern {
    type Location = usize;
    type Error = crate::scanner::ScanError;

    enum crate::scanner::Token {
        "class" => Token::KwdClass,
        "extern" => Token::KwdExtern,
        "for" => Token::KwdFor,
        "fn" => Token::KwdFn,
        "in" => Token::KwdIn,
        "let" => Token::KwdLet,
        "match" => Token::KwdMatch,
        "return" => Token::KwdReturn,
        "use" => Token::KwdUse,

        "->" => Token::SymArrow,
        "=>" => Token::SymDblArrow,
        ".." => Token::SymDblDot,

        ":" => Token::SymColon,
        "," => Token::SymComma,
        "-" => Token::SymDash,
        "." => Token::SymDot,
        "=" => Token::SymEqual,
        "(" => Token::SymParenL,
        ")" => Token::SymParenR,
        "%" => Token::SymPercent,
        "+" => Token::SymPlus,
        ";" => Token::SymSemicolon,
        "/" => Token::SymSlash,
        "*" => Token::SymStar,
        "_" => Token::SymUnderscore,

        Int => Token::IntLiteral(<String>),
        String => Token::StringLiteral(<String>),
        Ident => Token::Ident(<Symbol>),

        Indent => Token::Indent,
        Dedent => Token::Dedent,
        LineSep => Token::Sep,
    }
}
