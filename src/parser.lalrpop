use symbol::Symbol;

use crate::ast::*;
use crate::Token;
use crate::Type;

#[LALR]
grammar;

pub Program: Program = MultiPunct<Sep, Decl> => Program(<>);

// todo: actually support repl commands?
pub Line: Line = Sep* <LineInner> Sep*;

/////

LineInner: Line = {
    Expr => Line::Expr(<>),
    Decl => Line::Decl(<>),
};

Class: Class = "class" Ident => Class { };

Decl: Decl = {
    <lo:@L> <_extern:Extern> <hi:@R> => Decl { kind: DeclKind::Extern(_extern), pos: (lo, hi) },
    <lo:@L> <class:Class> <hi:@R> => Decl { kind: DeclKind::Class(class), pos: (lo, hi) },
    <lo:@L> <func:Func> <hi:@R> => Decl { kind: DeclKind::Func(func), pos: (lo, hi) },
    <lo:@L> <_use:Use> <hi:@R> => Decl { kind: DeclKind::Use(_use), pos: (lo, hi) },
};

Expr: Expr = {
    <lo:@L> <expr1:Expr> <expr2:Expr2> <hi:@R> => Expr { kind: ExprKind::Call(Box::new(expr1), Box::new(expr2)), pos: (lo, hi), ty: Type::gen() },
    <expr:Expr2> => expr,
};

Expr2: Expr = {
    <lo:@L> <left:Expr2> "+" <right:Expr3> <hi:@R> => Expr { kind: ExprKind::BinOp(Box::new(left), Op::Add, Box::new(right)), pos: (lo, hi), ty: Type::gen() },
    <lo:@L> <left:Expr2> "-" <right:Expr3> <hi:@R> => Expr { kind: ExprKind::BinOp(Box::new(left), Op::Sub, Box::new(right)), pos: (lo, hi), ty: Type::gen() },

    <lo:@L> <_match:Match> <hi:@R> => Expr { kind: ExprKind::Match(Box::new(_match)), pos: (lo, hi), ty: Type::gen() },
    <lo:@L> <expr1:Expr3> ".." <expr2:Expr3> <hi:@R> => Expr { kind: ExprKind::Range(Box::new(expr1), Box::new(expr2)), pos: (lo, hi), ty: Type::gen() },
    <expr:Expr3> => expr,
};

Expr3: Expr = {
    <lo:@L> <left:Expr3> "*" <right:Expr4> <hi:@R> => Expr { kind: ExprKind::BinOp(Box::new(left), Op::Mul, Box::new(right)), pos: (lo, hi), ty: Type::gen() },
    <lo:@L> <left:Expr3> "/" <right:Expr4> <hi:@R> => Expr { kind: ExprKind::BinOp(Box::new(left), Op::Div, Box::new(right)), pos: (lo, hi), ty: Type::gen() },
    <lo:@L> <left:Expr4> "%" <right:Expr4> <hi:@R> => Expr { kind: ExprKind::BinOp(Box::new(left), Op::Mod, Box::new(right)), pos: (lo, hi), ty: Type::gen() },
    <expr:Expr4> => expr,
};

Expr4: Expr = {
    <lo:@L> <path:Path> <hi:@R> => Expr { kind: ExprKind::Path(path), pos: (lo, hi), ty: Type::gen() },
    <lo:@L> <int:Int> <hi:@R> => Expr { kind: ExprKind::IntLiteral(int), pos: (lo, hi), ty: Type::gen() },
    <lo:@L> <str:String> <hi:@R> => Expr { kind: ExprKind::StringLiteral(str), pos: (lo, hi), ty: Type::gen() },
    <lo:@L> "(" ")" <hi:@R> => Expr { kind: ExprKind::Unit, pos: (lo, hi), ty: Type::Unit },
    <lo:@L> "(" <expr:Expr> ")" <hi:@R> => Expr { kind: expr.kind, pos: (lo, hi), ty: Type::gen() },
    <lo:@L> "(" <expr:Expr> "," ")" <hi:@R> => Expr { kind: ExprKind::Tuple(vec![expr]), pos: (lo, hi), ty: Type::gen() },
    <lo:@L> "(" <exprs:PunctTwo<",", Expr>> ")" <hi:@R> => Expr { kind: ExprKind::Tuple(exprs), pos: (lo, hi), ty: Type::gen() },
};

Extern: Extern = "extern" <name:Ident> ":" <ty:TypeLiteral> => Extern { name, ty };

Func: Func = "func" <name:Ident> <args:FuncArg*> <returns:FuncReturn?> "=" <body:Body<MultiPunct<Sep, Stmt>>> => Func { name, args, returns: returns.unwrap_or_else(|| Type::Unit), body, ty: Type::gen() };

FuncArg: FuncArg = {
    "(" <name:Ident> ":" <ty:TypeLiteral> ")" => FuncArg(name, ty),
    <name:Ident> => FuncArg(name, Type::gen()),
};

FuncSig = Ident FuncArg* FuncReturn?;

FuncReturn: Type = "->" <ty:TypeLiteral> => ty;

LValue: LValue = {
    <name:Ident> => LValue::Ident(name),
};

Match: Match = "match" <expr:Expr> ":" <body:Body<MultiPunct<Sep, MatchArm>>> => Match(expr, body);

MatchArm: MatchArm = <pat:Pattern> "=>" <expr:Expr> => MatchArm(pat, expr);

Path: Path = {
    <name:Ident> => Path(vec![name]),
    <path:Path> "." <name:Ident> => { let mut path = path; path.0.push(name); path },
};

Pattern: Pattern = {
    "_" => Pattern::Wildcard,
    <int:Int> => Pattern::IntLiteral(int),
    <str:String> => Pattern::StringLiteral(str),
    <name:Ident> => Pattern::Var(name),
    "(" <pats:Punct<",", Pattern>> ")" => Pattern::Tuple(pats),
};

Stmt: Stmt = {
    <lo:@L> <expr:Expr> <hi:@R> => Stmt { kind: StmtKind::Expr(expr), pos: (lo, hi) },
    <lo:@L> "let" <lvalue:LValue> "=" <expr:Expr> <hi:@R> => Stmt { kind: StmtKind::Let(lvalue, expr), pos: (lo, hi) },
    <lo:@L> "for" <pat:Pattern> "in" <expr:Expr> ":" <body:Body<MultiPunct<Sep, Stmt>>> <hi:@R> => Stmt { kind: StmtKind::ForLoop(pat, expr, body), pos: (lo, hi) },
};

TypeLiteral: Type = {
    <ty:TypeLiteral2> => ty,
    <ty1:TypeLiteral2> "->" <ty2:TypeLiteral> => Type::Func(Box::new(ty1), Box::new(ty2)),
};

TypeLiteral2: Type = {
    <name:Ident> => Type::Var(name),
    "(" <ty:TypeLiteral> ")" => ty,
};

Use: Use = "use" <paths:UsePath> => Use(paths);

UsePath: Vec<Path> = {
    <path:Path> => vec![path],
    <outer:Path> "." "(" <inner:Punct<",", UsePath>> ")" => {
        inner.into_iter().flatten().map(|suffix| { let mut outer = outer.clone(); outer.0.extend(suffix.0); outer }).collect()
    },
};

// use a.(b, c)

// use a.(b.(c, h), d.(e.f, g))
// -
// use a.b.c
// use a.b.h
// use a.d.e.f
// use a.d.g

// macros

Sep = {
    ";",
    LineSep,
};

Body<T>: T = {
    "(" <t:T> ")" => t,
    Sep* Indent <t:T> Dedent => t,
};

MultiPunct<D, T>: Vec<T> = {
    <f:T?> <v:(D+ <T>)*> D* => match f {
        None => v,
        Some(f) => {
            let mut v = v;
            v.insert(0, f);
            v
        },
    }
}

Punct<D, T>: Vec<T> = {
    <f:T?> <v:(D <T>)*> D? => match f {
        None => v,
        Some(f) => {
            let mut v = v;
            v.insert(0, f);
            v
        },
    }
}

PunctOne<D, T>: Vec<T> = {
    <f:T> <v:(D <T>)*> D? => {
        let mut v = v;
        v.insert(0, f);
        v
    }
}

PunctTwo<D, T>: Vec<T> = {
    <f:T> D <s:T> <v:(D <T>)*> D? => {
        let mut v = v;
        v.insert(0, f);
        v.insert(1, s);
        v
    }
}

extern {
    type Location = usize;
    type Error = crate::ParseError;

    enum crate::scanner::Token {
        "class" => Token::KwdClass,
        "extern" => Token::KwdExtern,
        "for" => Token::KwdFor,
        "func" => Token::KwdFunc,
        "in" => Token::KwdIn,
        "let" => Token::KwdLet,
        "match" => Token::KwdMatch,
        "use" => Token::KwdUse,

        "->" => Token::SymArrow,
        "=>" => Token::SymDblArrow,
        ".." => Token::SymDblDot,

        ":" => Token::SymColon,
        "," => Token::SymComma,
        "-" => Token::SymDash,
        "." => Token::SymDot,
        "=" => Token::SymEqual,
        "(" => Token::SymParenL,
        ")" => Token::SymParenR,
        "%" => Token::SymPercent,
        "+" => Token::SymPlus,
        ";" => Token::SymSemicolon,
        "/" => Token::SymSlash,
        "*" => Token::SymStar,
        "_" => Token::SymUnderscore,

        Int => Token::IntLiteral(<String>),
        String => Token::StringLiteral(<String>),
        Ident => Token::Ident(<Symbol>),

        Indent => Token::Indent,
        Dedent => Token::Dedent,
        LineSep => Token::Sep,
    }
}
